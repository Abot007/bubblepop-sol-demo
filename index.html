<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Crypto Invaders – Candlestick Edition</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #000;
      color: #fff;
      font-family: sans-serif;
    }
    #chargeBar {
      position: absolute;
      bottom: 10px;
      left: 10px;
      width: 200px;
      height: 20px;
      background: #333;
      border: 1px solid #fff;
    }
    #chargeFill {
      height: 100%;
      background: lime;
      width: 0%;
    }
    /* Disable context menu on canvas */
    canvas {
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -khtml-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <div id="chargeBar">
    <div id="chargeFill"></div>
  </div>

  <script>
    // Get canvas and context
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    // Arrays for game objects
    let bullets = [];       // regular (green) bullets
    let powerBullets = [];  // power-up (cyan) bullets
    let enemies = [];
    let enemyCounter = 0;   // unique enemy IDs

    // Player (crypto influencer) definition
    const player = {
      x: canvas.width / 2,
      y: canvas.height - 50,
      width: 40,
      height: 40,
      charge: 0,       // Charge meter from 0 to 100
      chargeRate: 0.1  // Increment per frame
    };

    // Enemy spawn settings
    let enemySpawnTimer = 0;
    const enemySpawnInterval = 80; // frames between spawns

    // Freeze duration for medium/large enemies (in frames)
    const freezeDuration = 30;

    // Listen for mouse movement to control the player horizontally
    document.addEventListener("mousemove", function (e) {
      player.x = Math.min(
        Math.max(e.clientX, player.width / 2),
        canvas.width - player.width / 2
      );
    });

    // Left-click: fire a regular bullet
    document.addEventListener("click", function (e) {
      fireBullet();
    });

    // Right-click: fire a power-up shot (if charged)
    document.addEventListener("contextmenu", function (e) {
      e.preventDefault();
      firePowerShot();
    });

    // Fire a regular (green) bullet
    function fireBullet() {
      bullets.push({
        x: player.x,
        y: player.y - player.height / 2,
        width: 8,
        height: 20,
        speed: 7,
        // To prevent repeated hits on the same enemy
        hitCooldown: {},
        attached: false, // indicates if bullet is attached to an enemy
        attachedTo: null // enemy id to which it is attached
      });
    }

    // Fire a power-up bullet (cyan) if fully charged
    function firePowerShot() {
      if (player.charge >= 100) {
        player.charge = 0;
        powerBullets.push({
          x: player.x,
          y: player.y - player.height / 2,
          width: 16,
          height: 40,
          speed: 10,
          hitCooldown: {},
          attached: false,
          attachedTo: null
        });
      }
    }

    // Draw the candlestick-chart style background with grid lines
    function drawBackground() {
      ctx.fillStyle = "#000";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.strokeStyle = "rgba(255,255,255,0.1)";
      ctx.lineWidth = 1;
      const gridSpacing = 50;
      for (let x = 0; x <= canvas.width; x += gridSpacing) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
      }
      for (let y = 0; y <= canvas.height; y += gridSpacing) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
      }
    }

    // Spawn an enemy with random size: small, medium, or large
    function spawnEnemy() {
      const sizeTypes = ["small", "medium", "large"];
      const type = sizeTypes[Math.floor(Math.random() * sizeTypes.length)];
      let enemy = {
        id: enemyCounter++,
        x: Math.random() * (canvas.width - 60) + 30,
        y: -50,
        pushed: false, // whether the enemy is being pushed upward
        baseSpeed: 1,  // downward speed before being hit
        upSpeed: 5,    // maximum upward speed
        freezeTimer: 0, // frames to pause when fully hit (for medium/large)
        extraHits: 0    // count of hits beyond the required final hit
      };

      if (type === "small") {
        enemy.width = 20;
        enemy.height = 40;
        enemy.initialHits = 1;
        enemy.hitsRemaining = 1;
      } else if (type === "medium") {
        enemy.width = 30;
        enemy.height = 60;
        enemy.initialHits = 3;
        enemy.hitsRemaining = 3;
      } else if (type === "large") {
        enemy.width = 40;
        enemy.height = 80;
        enemy.initialHits = 5;
        enemy.hitsRemaining = 5;
      }
      // Start with downward speed
      enemy.speed = enemy.baseSpeed;
      return enemy;
    }

    // Simple rectangle collision detection
    function rectIntersect(a, b) {
      return !(
        a.x + a.width / 2 < b.x - b.width / 2 ||
        a.x - a.width / 2 > b.x + b.width / 2 ||
        a.y < b.y - b.height / 2 ||
        a.y - a.height > b.y + b.height / 2
      );
    }

    // Main update loop
    function update() {
      // Draw background grid first
      drawBackground();

      // Update player's charge meter
      if (player.charge < 100) {
        player.charge += player.chargeRate;
        if (player.charge > 100) player.charge = 100;
      }
      document.getElementById("chargeFill").style.width = player.charge + "%";

      // Spawn enemies periodically
      enemySpawnTimer++;
      if (enemySpawnTimer >= enemySpawnInterval) {
        enemySpawnTimer = 0;
        enemies.push(spawnEnemy());
      }

      // Update bullets (if not attached, move upward; if attached, follow enemy)
      for (let i = bullets.length - 1; i >= 0; i--) {
        let bullet = bullets[i];
        if (!bullet.attached) {
          bullet.y -= bullet.speed;
        }
        // Update cooldowns per enemy id
        for (let key in bullet.hitCooldown) {
          if (bullet.hitCooldown[key] > 0) {
            bullet.hitCooldown[key]--;
          } else {
            delete bullet.hitCooldown[key];
          }
        }
      }
      // Similarly for power bullets
      for (let i = powerBullets.length - 1; i >= 0; i--) {
        let pBullet = powerBullets[i];
        if (!pBullet.attached) {
          pBullet.y -= pBullet.speed;
        }
        for (let key in pBullet.hitCooldown) {
          if (pBullet.hitCooldown[key] > 0) {
            pBullet.hitCooldown[key]--;
          } else {
            delete pBullet.hitCooldown[key];
          }
        }
      }

      // Draw bullets (green) – if attached, update their position relative to the enemy
      ctx.fillStyle = "lime";
      for (let bullet of bullets) {
        if (bullet.attached) {
          // Find the enemy with this id
          let enemy = enemies.find(e => e.id === bullet.attachedTo);
          if (enemy) {
            // Position bullet so that its top edge touches enemy's bottom edge
            bullet.x = enemy.x; 
            bullet.y = enemy.y + enemy.height / 2 + bullet.height;
          }
        }
        ctx.fillRect(
          bullet.x - bullet.width / 2,
          bullet.y - bullet.height,
          bullet.width,
          bullet.height
        );
      }
      // Draw power bullets (cyan)
      ctx.fillStyle = "cyan";
      for (let pBullet of powerBullets) {
        if (pBullet.attached) {
          let enemy = enemies.find(e => e.id === pBullet.attachedTo);
          if (enemy) {
            pBullet.x = enemy.x;
            pBullet.y = enemy.y + enemy.height / 2 + pBullet.height;
          }
        }
        ctx.fillRect(
          pBullet.x - pBullet.width / 2,
          pBullet.y - pBullet.height,
          pBullet.width,
          pBullet.height
        );
      }

      // Draw player (yellow square)
      ctx.fillStyle = "yellow";
      ctx.fillRect(
        player.x - player.width / 2,
        player.y - player.height / 2,
        player.width,
        player.height
      );

      // Process enemies
      for (let i = enemies.length - 1; i >= 0; i--) {
        let enemy = enemies[i];

        // Process collisions with regular bullets
        for (let bullet of bullets) {
          // Only process if bullet is not yet attached and if enemy not on cooldown for this bullet
          if (!bullet.attached && rectIntersect(bullet, enemy) && !(enemy.id in bullet.hitCooldown)) {
            // For small enemies, immediately push upward.
            if (enemy.initialHits === 1) {
              enemy.hitsRemaining = 0;
              enemy.pushed = true;
              enemy.speed = enemy.upSpeed;
            } else {
              // For medium and large:
              if (enemy.hitsRemaining > 0) {
                enemy.hitsRemaining--;
                // If not yet fully damaged, slow down proportionally:
                if (enemy.hitsRemaining > 0) {
                  enemy.speed = enemy.baseSpeed * (enemy.hitsRemaining / enemy.initialHits);
                } else {
                  // On the final required hit, freeze the enemy
                  enemy.freezeTimer = freezeDuration;
                  enemy.pushed = true;
                  enemy.speed = 0;
                }
              } else if (enemy.hitsRemaining <= 0 && enemy.freezeTimer <= 0) {
                // If enemy is frozen and extra hits come in after freeze, count them
                enemy.extraHits = (enemy.extraHits || 0) + 1;
                // Gradually increase upward speed proportionally to extra hits
                // Here, for medium, assume maximum extra hits of 3; for large, maximum of 5
                let maxExtra = (enemy.initialHits === 3) ? 3 : 5;
                enemy.speed = enemy.upSpeed * Math.min(enemy.extraHits / maxExtra, 1);
              }
            }
            // Attach the bullet to the enemy so it sticks
            bullet.attached = true;
            bullet.attachedTo = enemy.id;
            // Set a cooldown so the same bullet doesn't register multiple collisions immediately.
            bullet.hitCooldown[enemy.id] = 20;
          }
        }
        // Process collisions with power bullets (same logic applies)
        for (let pBullet of powerBullets) {
          if (!pBullet.attached && rectIntersect(pBullet, enemy) && !(enemy.id in pBullet.hitCooldown)) {
            if (enemy.initialHits === 1) {
              enemy.hitsRemaining = 0;
              enemy.pushed = true;
              enemy.speed = enemy.upSpeed;
            } else {
              if (enemy.hitsRemaining > 0) {
                enemy.hitsRemaining--;
                if (enemy.hitsRemaining > 0) {
                  enemy.speed = enemy.baseSpeed * (enemy.hitsRemaining / enemy.initialHits);
                } else {
                  enemy.freezeTimer = freezeDuration;
                  enemy.pushed = true;
                  enemy.speed = 0;
                }
              } else if (enemy.hitsRemaining <= 0 && enemy.freezeTimer <= 0) {
                enemy.extraHits = (enemy.extraHits || 0) + 1;
                let maxExtra = (enemy.initialHits === 3) ? 3 : 5;
                enemy.speed = enemy.upSpeed * Math.min(enemy.extraHits / maxExtra, 1);
              }
            }
            pBullet.attached = true;
            pBullet.attachedTo = enemy.id;
            pBullet.hitCooldown[enemy.id] = 20;
          }
        }

        // Update freeze timer if enemy is frozen
        if (enemy.freezeTimer > 0) {
          enemy.freezeTimer--;
          // While frozen, enemy.speed remains 0
        }

        // Update enemy position:
        if (enemy.pushed) {
          enemy.y -= enemy.speed; // move upward
        } else {
          enemy.y += enemy.speed; // move downward
        }

        // Draw enemy as a red candlestick with a black border
        ctx.fillStyle = "red";
        ctx.fillRect(
          enemy.x - enemy.width / 2,
          enemy.y - enemy.height / 2,
          enemy.width,
          enemy.height
        );
        ctx.strokeStyle = "black";
        ctx.lineWidth = 2;
        ctx.strokeRect(
          enemy.x - enemy.width / 2,
          enemy.y - enemy.height / 2,
          enemy.width,
          enemy.height
        );

        // Remove enemy if off-screen (above or below)
        if (enemy.y + enemy.height < 0 || enemy.y - enemy.height > canvas.height) {
          enemies.splice(i, 1);
        }
      }

      requestAnimationFrame(update);
    }

    // Start game loop
    update();

    // Resize canvas on window resize
    window.addEventListener("resize", function () {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    });
  </script>
</body>
</html>
